/*
题目描述
【题目背景】

求知的隐士将知识传授给懵懂无知的凡人。隐士每年将提出 n 个正确的观点和 m 个错误的观点，且 n ≤ m。其中正确的观点用数字“1”表示，错误的观 点用数字“0”表示。例如，如果他提出了 3 个正确观点和 2 个错误观点，序列 可能是“11100”或“10101”。人们按序列的顺序讨论这些问题。 

隐士定义，一条观点序列是好的，当且只当序列中错误观点数量与正确观点数量之差为 K。也就是说，K = m－n。隐士同时注意到：当某个观点序列的所有子段中，K 的最大值恰好是 k 时，人们获得知识的效果最为理想。现在隐士希望小景编写一个程序，使他不必手造观点序列。

【题目描述】


序列需恰好包含 n 个 1 和 m 个 0 ，并且所有子段的K的最大值恰为 k 。 保证给出的数据一定存在符合要求的序列。 

形式化地，设某序列 s 包含 ns 个 1 和 ms 个 0，则 K 为 ts = ms－ns。s 的 所有子成集合{s1, s2, ..., sn，}，此时 k = max(ts1, ts2, ..., tsn)


输入
一行 3 个正整数 n, m, k，表示正确观点个数，错误观点个数和最优的 K。

输出
输出满足条件且字典序最小的 01 字符串。
样例输入 Copy
【样例1】
2 3 2
【样例2】
 5 10 8
样例输出 Copy
【样例1】
00101
【样例2】
000000001010111
提示
【样例说明】 

对于样例 1 的解释:取前 2 位（00），可以取得所有子段的 K 的最大值，恰为 2，且字典序最小。 

对于样例 2 的解释:取前 8 位，可以取得所有子段的 K 的最大值，恰为 8，且字典序最小。 

【数据范围与约定】

m－n ≤ k ≤ max(m, n), n + m ≥ 1；

10 %的数据：1 ≤ n, m ≤ 50；

60 %的数据：1 ≤ n, m ≤ 10 4；

100 %的数据：1 ≤ n, m ≤ 2×105，且 n ≤ m。

子段：原序列中一段连续的非空子序列。例如，假定原序列为“abcde”， 其字段有“a”“c”“de”“abc”“bcde”“abcde”等。

字典序：对于数字，不同排列的字典序是从左到右逐个比较对应的数字的先 后来决定的。例如对于 4 个数字的排列 1234 和 1243 ，排列 1234 在前（称 为字典序更小），排列 1243 在后（称为字典序更大）。


*/
/*
为了解决这个问题，我们需要构造一个恰好包含 n 个正确观点（用 '1' 表示）和 m 个错误观点（用 '0' 表示）的 01 字符串。该字符串的所有连续子段中，错误观点数量与正确观点数量之差（即 0 的个数减 1 的个数）的最大值必须恰好等于给定的 k，并且要求字典序最小。

方法思路
问题分析：

我们需要构造一个字符串，包含 n 个 '1' 和 m 个 '0'。

对于任意连续子段，定义其差值为（0 的个数 - 1 的个数），所有子段中的最大差值必须恰好为 k。

字典序最小要求我们尽可能在字符串的前面放置 '0'（因为 '0' 的 ASCII 值小于 '1'）。

关键观察：

整个序列的差值 total = m - n（因为总共有 m 个 '0' 和 n 个 '1'）。

题目保证 m - n ≤ k ≤ max(m, n)，且数据一定存在解。

使用贪心策略：从左到右逐个确定字符，优先放置 '0'（以保证字典序最小），但需确保放置后不会导致任何子段的差值超过 k，并且最终存在某个子段的差值等于 k。

贪心策略：

维护当前前缀的差值 cur（即当前 0 的个数减 1 的个数）。

维护历史最小前缀差值 min_prev（用于计算以当前位置结尾的子段的最大差值）。

对于每个位置：

尝试放置 '0'：计算放置后的新前缀差值 new_cur = cur + 1，并检查条件：

以当前位置结尾的最大子段差值 new_cur - old_min_prev 不超过 k。

新前缀差值 new_cur 不小于 total - k（确保最终最小前缀差值不会太小，从而保证整个序列的最大子段差值不超过 k）。

如果条件满足，放置 '0'；否则尝试放置 '1'。

放置 '1'：类似地，计算 new_cur = cur - 1 并检查相同条件。

如果两个条件均不满足（题目保证有解，这种情况理论上不会发生），则根据剩余字符数量强制放置 '0' 或 '1'。
*/
#include <stdio.h>

// 定义min宏，用于比较两个值的最小值
#define min(a, b) ((a) < (b) ? (a) : (b))

int main() {
    int n, m, k;
    // 读取输入
    scanf("%d %d %d", &n, &m, &k);
    
    int total = m - n;  // 整个序列的差值
    int cur = 0;        // 当前前缀差值
    int min_prev = 0;   // 历史最小前缀差值
    int r0 = m;         // 剩余0的数量
    int r1 = n;         // 剩余1的数量
    
    // 分配足够空间存储结果字符串（n+m个字符 + 1个结束符）
    char ans[n + m + 1];
    int index = 0;      // 当前填充位置
    
    // 循环处理每个位置
    for (int i = 0; i < n + m; i++) {
        int old_min_prev = min_prev; // 保存当前历史最小值
        int placed = 0;              // 标记是否已放置字符
        
        // 尝试放置'0'
        if (r0 > 0) {
            int new_cur0 = cur + 1;
            // 检查两个条件是否满足
            if ((new_cur0 - old_min_prev <= k) && (new_cur0 >= total - k)) {
                ans[index++] = '0';
                r0--;
                cur = new_cur0;
                min_prev = min(min_prev, new_cur0);
                placed = 1;
            }
        }
        
        // 尝试放置'1'
        if (!placed && r1 > 0) {
            int new_cur1 = cur - 1;
            // 检查两个条件是否满足
            if ((new_cur1 - old_min_prev <= k) && (new_cur1 >= total - k)) {
                ans[index++] = '1';
                r1--;
                cur = new_cur1;
                min_prev = min(min_prev, new_cur1);
                placed = 1;
            }
        }
        
        // 如果都不满足，则根据剩余字符强行放置
        if (!placed) {
            if (r0 > 0) {
                ans[index++] = '0';
                r0--;
                cur++;
                min_prev = min(min_prev, cur);
            } else {
                ans[index++] = '1';
                r1--;
                cur--;
                min_prev = min(min_prev, cur);
            }
        }
    }
    
    ans[index] = '\0'; // 添加字符串结束符
    printf("%s\n", ans);
    
    return 0;
}
/*
代码说明：
输入处理：

使用scanf读取三个整数：n（正确观点数）、m（错误观点数）和k（最优差值）

初始化：

total：整个序列的差值（m - n）

cur：当前前缀的差值（初始为0）

min_prev：历史最小前缀差值（初始为0）

r0和r1：剩余'0'和'1'的数量

ans：预分配足够空间的字符数组，用于存储结果字符串

构造字符串：

循环处理每个位置（共n+m个位置）

尝试放置'0'：

计算新前缀差值new_cur0 = cur + 1

检查两个条件是否同时满足：

new_cur0 - old_min_prev <= k（子段差值不超过k）

new_cur0 >= total - k（保证后续不会超过k）

如果满足则放置'0'，更新相关变量

尝试放置'1'（类似逻辑）：

计算new_cur1 = cur - 1

检查相同条件

如果都不满足，根据剩余字符强行放置（优先'0'保证字典序）

输出结果：

在字符串末尾添加结束符\0

使用printf输出结果字符串

该实现完全遵循了原始Python代码的逻辑，同时满足C语言的语法限制，不使用指针和容器，通过预分配数组空间处理字符串构建，能够高效处理题目要求的最大数据规模（n, m ≤ 2×10⁵）。
*/
