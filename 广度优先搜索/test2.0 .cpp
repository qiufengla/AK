/*
题目描述
马里奥是一个快乐的油漆工人，这天他接到了一个油漆任务，要求马里奥把一个n行m列的矩阵每一格都用油漆标记一个数字，标记的顺序按照广度优先搜索的方式进行，也就是他会按照如下方式标记：

1、首先标记第1行第1列的单元格，标记数字为1；

2、然后标记当前单元格上下左右四个方向所有能标记的单元格，且：

① 标记顺序按照：右、下、左、上的优先级；

② 不能标记到矩阵外，且标记过的数字不能重复标记；

3、当本单元格标记结束，寻找比本单元格中数字大1的单元格，标记那个单元格的上下左右四个方向，也是按照步骤2所示的要求进行标记。

依次类推，直到所有单元格都被标记。

 

比如：如果有一个3 * 3的矩阵如下，那么首先标记1,1单元格，并按照上面步骤2的要求标记其四周能够标记的单元格，标记结果如下：

 

接下来，标记比1,1格大1的数字的四周的单元格，也就是标记值为2的单元格四周的单元格，标记结果如下：



接下来标记值为3的单元格四周的单元格，标记结果如下：


 

接下来标记值为4的单元格四周的单元格，标记结果如下：


 

接下来标记值为5的单元格四周的单元格，标记结果如下：


 

接下来标记值为6的单元格四周的单元格，但这个数字四周的单元格已经被标记，因此继续标记值为7四周的单元格，标记结果如下：


 

此时，发现标记结束，得到如上图所示的标记结果。

输入
两个整数n和m，n和m都是3~100之间的整数。

输出
输出n行m列的标记后的矩阵，输出每个数后空一格。

样例输入 Copy
3 3
样例输出 Copy
1 2 4
3 5 7
6 8 9

*/
#include <bits/stdc++.h>
#include<math.h>
#include<cstring>
#include<string.h>
using namespace std;
const int MX=100; 
long long int n,m;
int a[MX+10][MX+10],dp[MX+10];
int q[10100][3];
int fx[5]={0,0,1,0,-1};
int fy[5]={0,1,0,-1,0};
int tx,ty,k=1;
int main()
{
    cin>>n>>m;
    int head=1,tail=1;
    a[1][1]=k;
    k++;
    q[1][1]=1;
    q[1][2]=1;
    while(head<=tail)
    {
        for(int i=1;i<=4;i++)
        {
            tx=q[head][1]+fx[i];
            ty=q[head][2]+fy[i];
            if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&a[tx][ty]==0)
            {
                tail++;
                q[tail][1]=tx;
                q[tail][2]=ty;
                a[tx][ty]=k;
                k++;
            }
        }
        head++;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cout<<a[i][j]<<' ';
        }
        cout<<'\n';
    }
    return 0;    
}
/**************************************************************
    Problem: 23881
    User: 2024JK070430
    Language: C++
    Result: 正确
    Time:2 ms
    Memory:2388 kb
****************************************************************/