/*
题目描述
有 n 张演唱会门票可供选择，每张都有一定的价格。然后，m 个客户陆续到来。
每个客户都会宣布他们愿意为机票支付的最高价格，在此之后，他们将获得一张价格最接近的机票，使其不超过最高价格。
输入
第一个输入行包含整数 n 和 m（1≤ n， m≤ 2*105）：票证数量和客户数量。
下一行包含 n 个整数 h1，h2,...,hn（1≤ hi≤ 109）：每张票的价格。
最后一行包含 m 个整数 t1，t2,...,tm（1≤ ti≤ 109）：每个客户到达的订单中的最高价格。
输出
为每个客户打印他们将为机票支付的价格。在此之后，将无法再次购买机票。
如果客户无法获得任何票证，请打印 -1。
样例输入 复制
5 3
5 3 7 8 5
4 8 3
样例输出 Copy
3
8
-1
*/

#include<bits/stdc++.h>
using namespace std;
const int MX=1e6;
int a[MX+10];
int T,n,m,x,i,cnt,sum;
map<int,int>p;
int main()
{
	
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		p[a[i]]++;
	}
	sort(a+1,a+n+1);
	for (int i = 0; i < m; i++)
	{
        int x;
        cin >> x;
        // 使用二分查找找到最大的 <=x 且存在的数字
        auto it = p.upper_bound(x);
        if (it != p.begin()) 
		{
            --it; // 移动到前一个元素
            cout << it->first << '\n';
            // 更新计数
            if (--(it->second) == 0) 
			{
                p.erase(it);
            }
        } 
		else 
		{
            cout << -1 << '\n';
        }
    }
	return 0;
}

/*
代码注释
1.第一处
if (it != p.begin()) {
    --it; // 移动到前一个元素（即最大的 ≤x 的元素）
    // ... 输出并更新计数
} 
else 
{
    cout << -1 << '\n'; // 不存在 ≤x 的元素
}
it != p.begin()：若 it 不是 p 的起始位置，说明存在 ≤x 的元素。
通过 --it 移动到前一个元素，即 最大的 ≤x 的元素。
若 it == p.begin()，说明所有元素都大于 x，输出 -1。
---------------------------------------------------------------------
2.第二处
cout << it->first << '\n'; // 输出最大的 ≤x 的数字
if (--(it->second) == 0) {
    p.erase(it); // 若该数字用完，从 map 中删除
}
it->first：当前数字的值。
it->second：该数字的剩余次数。
每次使用后将计数减 1，若减为 0，则从 map 中删除该元素，确保后续查询不再使用它。

高效查找：利用 map 的有序性和 upper_bound 的二分查找特性，时间复杂度为 O(log n)（n 是 map 的大小）。
动态维护：每次使用后更新计数，确保每个数字最多被使用其输入次数。
边界处理：通过判断 it != p.begin() 避免越界，确保正确性。
这种方法比原始代码的线性扫描更高效，尤其在处理大量查询时优势明显。

*/
