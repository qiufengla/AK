/*
题目描述
现有n个洒水器，给花园浇水。为了简化问题，把花园简化成一条直线，直线长度为m-1，有m个坐标位置，依次为：1,2,3,....,m。
洒水器排成一排，第i个洒水器的坐标位置为di，洒水器的洒水强度为wi。第i个洒水器工作时，在距离di为x（x<wi）的位置能喷洒的水量为wi-x，x≥wi 的位置无法喷洒水。
当n个洒水器同时开始工作时，请依次计算出花园坐标位置1,2,...,m被喷洒的累计水量
输入
第一行两个整数n,m，表示有n个洒水器，花园里的坐标位置最大值为m。
第二行n个整数d1,d2,...,dn，表示洒水器的位置。
第二行n个整数w1,w2,...,wn，表示洒水器的洒水强度。
输出
输出一行m个整数，用空格隔开， 第i(1≤i≤m)个整数表示花园坐标位置为i的累计洒水量
样例输入 Copy
【样例1】
1 5
4
3
【样例2】
2 5
2 4
4 3
【样例3】
2 5
2 2
2 4
【样例4】
3 30
6 8 20 
5 3 10
样例输出 Copy
【样例1】
0 1 2 3 2
【样例2】
3 5 5 5 3
【样例3】
4 6 4 2 1
【样例4】
0 1 2 3 4 6 6 6 4 2 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1 0
提示
对于100%的数据，1≤n≤m≤106,1≤di≤m(1≤i≤n),1≤wi≤m(1≤i≤n)。
对于20%的数据，di=1。
对于另外20%的数据，di=m。
对于另外20%的数据，n,m≤1000。
*/
#include <stdio.h>

#define min(a, b) ((a) < (b) ? (a) : (b))
#define max(a, b) ((a) > (b) ? (a) : (b))

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    
    int d[n], w[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &d[i]);
    }
    for (int i = 0; i < n; i++) {
        scanf("%d", &w[i]);
    }
    
    long long A[m + 2];
    long long B[m + 2];
    for (int i = 0; i <= m + 1; i++) {
        A[i] = 0;
        B[i] = 0;
    }
    
    for (int i = 0; i < n; i++) {
        int d_val = d[i];
        int w_val = w[i];
        
        int L = max(1, d_val - w_val + 1);
        int R = d_val;
        if (L <= R) {
            A[L] += (long long)(w_val - d_val);
            A[R + 1] -= (long long)(w_val - d_val);
            B[L] += 1;
            B[R + 1] -= 1;
        }
        
        int L2 = d_val + 1;
        int R2 = min(m, d_val + w_val);
        if (L2 <= R2) {
            A[L2] += (long long)(w_val + d_val);
            A[R2 + 1] -= (long long)(w_val + d_val);
            B[L2] -= 1;
            B[R2 + 1] += 1;
        }
    }
    
    for (int i = 1; i <= m; i++) {
        A[i] = A[i - 1] + A[i];
        B[i] = B[i - 1] + B[i];
    }
    
    for (int i = 1; i <= m; i++) {
        long long ans_i = A[i] + B[i] * i;
        printf("%lld", ans_i);
        if (i < m) {
            printf(" ");
        } else {
            printf("\n");
        }
    }
    
    return 0;
}
/*
为了解决这个问题，我们需要高效地计算每个花园位置被喷洒的累计水量。每个洒水器在特定位置的影响可以分解为常数部分和线性部分，通过差分数组技术可以高效地处理这些影响。

方法思路
问题分析：

每个洒水器在位置 d 上，洒水强度为 w。

洒水器的影响范围是 [d - w + 1, d + w]，其中：

左侧区间 [d - w + 1, d] 的贡献为 w - (d - x) = x + (w - d)。

右侧区间 [d + 1, d + w] 的贡献为 w - (x - d) = (w + d) - x。

差分数组技术：

使用两个差分数组 A 和 B：

A 记录常数部分的差分。

B 记录线性系数（斜率）的差分。

对于左侧区间：

在 L = max(1, d - w + 1) 处，A[L] += (w - d)，B[L] += 1。

在 R + 1 = d + 1 处，A[R + 1] -= (w - d)，B[R + 1] -= 1。

对于右侧区间：

在 L2 = d + 1 处，A[L2] += (w + d)，B[L2] -= 1。

在 R2 + 1 = min(m, d + w) + 1 处，A[R2 + 1] -= (w + d)，B[R2 + 1] += 1。

前缀和计算：

对数组 A 和 B 分别计算前缀和，得到每个位置的常数部分和线性系数。

每个位置 i 的累计水量为 A[i] + B[i] * i。
*/
/*
代码解释
输入处理：

读取洒水器数量 n 和花园最大位置 m。

读取每个洒水器的位置 d[i] 和强度 w[i]。

初始化差分数组：

数组 A 和 B 分别用于存储常数部分和线性系数的差分，初始化为零。

处理每个洒水器：

左侧区间处理：

计算有效区间 [L, R]，确保 L 不小于 1。

更新 A[L] 和 A[R + 1] 以记录常数部分的差分。

更新 B[L] 和 B[R + 1] 以记录线性系数的差分。

右侧区间处理：

计算有效区间 [L2, R2]，确保 R2 不超过 m。

更新 A[L2] 和 A[R2 + 1] 以记录常数部分的差分。

更新 B[L2] 和 B[R2 + 1] 以记录线性系数的差分。

计算前缀和：

对数组 A 和 B 分别计算前缀和，得到每个位置的常数部分和线性系数。

输出结果：

对于每个位置 i，计算累计水量 A[i] + B[i] * i 并输出。

这种方法高效地利用了差分数组技术，将每个洒水器的影响分解为常数和线性部分，通过前缀和快速计算每个位置的累计水量，时间复杂度为 O(n + m)，适合处理大规模数据。

*/
