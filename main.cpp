/*
题目描述24163
小可可发明了一种新的正方形划分方法。
首先我们有一个正方形，我们称该图形为第 0 轮的图形。我们将这个正方形均匀划分成 4 个部分——左上、右上、左下和右下，分别将其编号为 ABCD，称新的图形为第1 轮的图形。


我们再将第一个图形所划分的每一个部分 ABCD，分别再分成 4 个部分，称新的图形为第 2 轮的图形。对于该图形的每个部分的命名方式为该部分所属第 1 轮的部分的编号 + ABCD。如：原来第 1 轮的 A 部分的右上部分的编号为 AB。


第 3 轮及以上的图形以此类推。
这样每个方格都有一个编号，同时也有一个位置，即第几行（从上往下数）第几列（从左往右数）。现在小可可想实现编号与其位置的相互转化，请你写一份程序帮帮他。
输入
本题有多组测试数据，输入第一行一个整数 T 表示测试数据组数，接下来输入每组数据。
对于每组测试数据共一行，有以下两种可能：
0 n x y 表示该测试数据需要求出第 n 轮的图形中第 x 行第 y 列的格子的编号。
1 str 表示该测试数据需要求出编号为 str 的格子的位置。
如果仍然对输入方式不够清楚，可以去观察输入输出样例和样例解释。
输出
对于每组测试数据：
如果输入的测试数据为 0 n x y 的形式，输出一行一个字符串 str 表示该格子编号。
如果输入的测试数据为 1 str 的形式，输出一行三个整数 n, x, y 表示该格子位于第 n 轮图形的第 x 行第 y 列。
样例输入 Copy
3
0 1 2 1
1 AB
0 2 3 4
样例输出 Copy
C
2 1 2
DB
提示
样例解释：
第一行一个整数 3 表示我们一共有三组测试数据。
第一组测试数据 0 1 2 1，表示我们要将第 1 轮图形的第 2 行第 1 列的位置转化为编号，根据题意描述中的图可知编号为 C。
第二组测试数据 1 AB，表示我们要求出编号为 AB 的格子的位置，根据题意描述中的图可知它在第 2 轮第 1 行第 2 列。
第三组测试数据 0 2 3 4，表示我们要将第 2 轮图形的第 3 行第 4 列的位置转化为编号，根据题意描述中的图可知编号为 DB。

数据点 1，1 ≤ T ≤ 10, 1 ≤ n ≤ 2。
数据点 2, 3，1 ≤ T ≤ 10, 1 ≤ n ≤ 10。
数据点 4, 5，1 ≤ T ≤ 5 × 104, n = 10，即保证所有图形均为第 10 轮图形。
数据点 6，1 ≤ T ≤ 5 × 104, 1 ≤ n ≤ 30，询问仅形如 0 n x y。
数据点 7，1 ≤ T ≤ 5 × 104, 1 ≤ n ≤ 30，询问仅形如 1 str。
数据点 8 ∼ 10，1 ≤ T ≤ 5 × 104, 1 ≤ n ≤ 30。
*/
#include<bits/stdc++.h>
using namespace std;
const int MX=1e6;
int T,n,m,k,len,half,x,y;
string s,t;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>T;
    while(T--)
    {
        cin>>k;
        if(k==0)
        {
            s="";
            cin>>n>>x>>y;
            len=pow(2,n);
            for(int i=1;i<=n;i++)
            {
                half=len/2;
                if(x<=half)
                {
                    if(y<=half)
                    {
                        s=s+'A';
                    }
                    else
                    {
                        s=s+'B';
                        y=y-half;
                    }
                }
                else
                {
                    if(y<=half)
                    {
                        s=s+'C';
                        x=x-half;
                    }
                    else
                    {
                        s=s+'D';
                        x=x-half;
                        y=y-half;
                    }
                }
                len=half;
            }
            cout<<s<<'\n';
        }
        else
        {
            cin>>t;
            int l=t.size();
            len=pow(2,l);
            x=1,y=1;
            for(int i=0;i<l;i++)
            {
                half=len/2;
                if(t[i]=='B'||t[i]=='D')
                {
                    y+=half;
                }
                if(t[i]=='C'||t[i]=='D')
                {
                    x+=half;
                }
                len=half;
            }
            cout<<l<<' '<<x<<' '<<y<<'\n';
        }
    }
    return 0;
}
/*
题目分析
题目涉及一种递归的正方形划分方法，需要实现编号与位置之间的相互转换。关键在于理解划分规则和坐标转换的数学关系。

划分规则
第0轮：整个正方形。

第1轮：将正方形分成4个部分（A、B、C、D），A在左上，B在右上，C在左下，D在右下。

后续轮次：每个部分继续递归划分，编号为父部分编号 + 当前划分的编号（A、B、C、D）。

转换思路
位置转编号（0 n x y）：

从大到小逐轮处理，每轮将当前正方形分成4个小正方形。

根据坐标判断所在象限，确定该轮编号字符。

更新坐标为当前象限内的相对坐标。

拼接所有轮次的编号字符得到最终编号。

编号转位置（1 str）：

编号字符串长度即为轮次n。

从小到大逐字符处理，每个字符对应一轮划分。

根据字符类型（A、B、C、D）计算位置偏移量。

最终得到的位置即为整个正方形中的绝对位置。

AI代码
#include <iostream>
#include <string>
#include <cmath>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int T;
    cin >> T;
    
    while (T--) {
        int op;
        cin >> op;
        
        if (op == 0) {
            int n, x, y;
            cin >> n >> x >> y;
            long long len = 1LL << n; // 当前区域边长
            string s = "";
            
            for (int i = 0; i < n; i++) {
                long long half = len >> 1; // 半边长
                if (x <= half) {
                    if (y <= half) {
                        s += 'A';
                    } else {
                        s += 'B';
                        y -= half;
                    }
                } else {
                    if (y <= half) {
                        s += 'C';
                        x -= half;
                    } else {
                        s += 'D';
                        x -= half;
                        y -= half;
                    }
                }
                len = half; // 更新区域大小
            }
            cout << s << '\n';
        } else {
            string str;
            cin >> str;
            int n = str.size();
            long long len = 1LL << n; // 初始边长
            long long x = 1, y = 1;
            
            for (char c : str) {
                long long half = len >> 1; // 半边长
                if (c == 'B' || c == 'D') {
                    y += half; // 右半部分列偏移
                }
                if (c == 'C' || c == 'D') {
                    x += half; // 下半部分行偏移
                }
                len = half; // 更新区域大小
            }
            cout << n << " " << x << " " << y << '\n';
        }
    }
    
    return 0;
}
代码解释
输入处理：

使用 ios::sync_with_stdio(false) 和 cin.tie(0) 加速输入输出。

读取测试数据组数 T。

位置转编号（op=0）：

读取轮次 n 和坐标 (x, y)。

初始化当前区域边长 len = 2^n。

逐轮处理（共 n 轮）：

计算当前半边长 half。

根据坐标 (x, y) 判断所在象限，确定该轮字符（A、B、C、D）。

更新坐标为当前象限内的相对坐标。

将字符拼接到结果字符串。

更新区域大小为 half。

输出结果字符串。

编号转位置（op=1）：

读取编号字符串 str。

字符串长度即为轮次 n。

初始化区域边长 len = 2^n 和位置 (x, y) = (1, 1)。

逐字符处理：

计算当前半边长 half。

根据字符类型更新位置偏移：

'B' 或 'D'：列坐标增加 half（右半部分）。

'C' 或 'D'：行坐标增加 half（下半部分）。

更新区域大小为 half。

输出轮次 n 和最终位置 (x, y)。

复杂度分析
时间复杂度：每组数据最多处理30轮（n≤30），总处理次数为 O(T×30)，满足 T≤50000 的要求。

空间复杂度：O(1)，仅使用常数额外空间。

该方案高效处理了两种转换，符合题目数据规模要求。



*/