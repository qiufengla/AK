/*
题目描述
爬楼梯是很多体育老师训练学生体能的一种形式，为了增强训练效果，体育老师将爬楼梯升级为负重爬楼梯：楼梯的每一阶都有一个重量为 wi 的沙袋。
楼梯有 n 阶，上楼可以一步上一阶，也可以一步上两阶。踏上第 i 阶楼梯后，需要背上重量为wi 的沙袋才能继续向上爬。学生从起点出发，上完 n 阶，走到终点（终点处没有沙袋）。
小明想尽量轻松一些。
给出每阶楼梯上的沙袋重量 wi ，请你帮小明算出最后到达终点时的最小负重（背上所有沙袋的重量和）是多少？
例如下图，一共有 6 阶台阶，从第 1 阶到第 6 阶的沙袋重依次为 5, 1, 3, 9, 2, 1 。第一步上两阶，到达第 2 阶，负重为 1 ；再上一阶，到达第 3 阶，负重为 4 ；再上两阶 ，到达第 5 阶，负重为 6 ，最后上两阶到达终点，可以达到最小负重为 6 。


输入
第一行一个数字 n 。第二行 n 个数字，用空格隔开，第 i 个数字代表第 i 阶楼梯上沙袋的重量wi 。
输出
输出走完 n 阶的最小负重(经过楼梯的沙袋重量和)。
样例输入 Copy
【样例1】
3
10 15 20
【样例2】
10
1 100 1 1 1 100 1 1 100 1
样例输出 Copy
【样例1】
15
【样例2】
6
提示
对于30%的数据，2≤n≤1000,1≤wi≤1000。
对于100%的数据，2≤n≤105,1≤wi≤105。
*/
#include<bits/stdc++.h>
using namespace std;
const int MX=1e6;
int T,n,m;
long long int dp0,dp1,dp2,num;
string s,t,s1;
int w[MX+10];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>w[i];
    }
    dp1=w[1];
    dp2=min(dp0+w[2],dp1+w[2]);
    if(n==2)
    {
        cout<<min(dp1,dp2)<<'\n';
        return 0;
    }
    for(int i=3;i<=n;i++)
    {
        num=min(dp1,dp2)+w[i];
        dp1=dp2;
        dp2=num;
    }
    cout<<min(dp1,dp2)<<'\n';
    return 0;
}
/**************************************************************
    Problem: 24260
    User: 2024JK070430
    Language: C++
    Result: 正确
    Time:31 ms
    Memory:6128 kb
****************************************************************/
/*
为了解决这个问题，我们需要计算小明在爬楼梯过程中最小可能的负重。楼梯有n阶，每阶都有一个沙袋，小明可以选择一次爬一阶或两阶，但必须背上所到达阶梯的沙袋。目标是找到一条路径，使得小明到达终点（第n阶之后）时背上的沙袋总重量最小。

方法思路
动态规划：我们使用动态规划来记录到达每一阶楼梯时的最小负重。

状态定义：dp[i]表示到达第i阶楼梯（位置i）时的最小总负重。

状态转移：

对于位置1（第一阶），只能从起点走一阶到达，负重为w[0]。

对于位置2（第二阶），可以从起点直接走两阶到达（负重w[1]），或者先到第一阶再到第二阶（负重w[0] + w[1]），取最小值。

对于位置i（i >= 3），可以从位置i-2走两阶到达，或者从位置i-1走一阶到达，取这两种路径的最小值，并加上当前阶梯的沙袋重量w[i-1]。

终点处理：到达终点（位置n+1）有两种方式：

从位置n-1走两阶直接到达终点，负重为dp[n-1]。

从位置n走一阶到达终点，负重为dp[n]。

最终答案取min(dp[n-1], dp[n])。
*/
/*
#include <stdio.h>

#define min(a, b) ((a) < (b) ? (a) : (b))

int main() {
    int n;
    scanf("%d", &n);
    int w[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &w[i]);
    }

    if (n == 1) {
        printf("0\n");
        return 0;
    }

    long long dp0 = 0;
    long long dp1 = w[0];
    long long dp2 = min(dp0 + w[1], dp1 + w[1]);

    if (n == 2) {
        printf("%lld\n", min(dp1, dp2));
        return 0;
    }

    long long prev1 = dp1;
    long long prev2 = dp2;
    long long current;

    for (int i = 3; i <= n; i++) {
        current = min(prev1, prev2) + w[i - 1];
        prev1 = prev2;
        prev2 = current;
    }

    printf("%lld\n", min(prev1, prev2));
    return 0;
}
代码解释
输入处理：读取楼梯阶数n和每阶沙袋的重量数组w。

边界处理：

如果n == 1，直接输出0，因为小明可以直接跨过第一阶到达终点。

如果n == 2，计算并输出到达第一阶和第二阶的最小负重。

动态规划初始化：

dp0表示起点（位置0），负重为0。

dp1表示位置1（第一阶），负重为w[0]。

dp2表示位置2（第二阶），负重为min(w[1], w[0] + w[1])。

状态转移：对于位置i从3到n：

计算当前位置的最小负重：current = min(prev1, prev2) + w[i-1]。

更新前两个位置的值：prev1 = prev2，prev2 = current。

输出结果：最终答案为min(prev1, prev2)，即从位置n-1或位置n到达终点的最小负重。

这种方法高效地利用动态规划，通过滚动变量优化空间复杂度，时间复杂度为O(n)，适用于题目给定的数据范围。
*/