/*题目描述
小明最近迷上了一款游戏，并且很想成为这款游戏的高手，这款游戏需要用
资源来买装备。他刚开始的资源价值为0,于是他每天都会做日常任务来获得价值为1的资源。
这款游戏中有每日商店，小明已经提前知道了接下来n天会出现的装备，每个装备都有一个价格 ai和他的强度值 bi，并且如果当天不买这件装备以后就买不到了。
但小明想要在这n天中买到强度总和最高的装备，你能帮助他吗?
输入
第一行输入一个整数n代表天数。
接下来的n行每行两个整数ai和 bi,分别代表价格和强度值。
输出
输出一个整数，表求小明能在这n天内获得的最大总强度值。
样例输入 Copy
【样例1】
4
1 1
2 2
3 3
4 4
【样例2】
5
2 100
1 2
2 10
3 20
2 1
样例输出 Copy
【样例1】
4
【样例2】
22
提示
对于样例一，小明会把资源都留到第四天时购买获得强度值为4的装备。
对于样例二，小明会买第二天的装备，并把第三天资源留下来买第四天的装备。
对于 30%的数据，保证1≤n≤20。
对于 50%的数据，保证1≤n≤ 300,并且 ai≤i的数量不超过 20。
对于 100%的数据，保证 1≤n,ai,bi≤5000。
*/
#include<bits/stdc++.h>
using namespace std;
const int MX=1e5;
long long int T,n,m,a,b,num;
string s,t,s1;
long long int dp[MX+10];
int main()
{
    cin>>T;
    for(int i=1;i<=T;i++)
    {
        cin>>n>>m;
        if(n<=i)
        {
            for(int j=i;j>=n;j--)
            {
                dp[j]=max(dp[j],dp[j-n]+m);
                num=max(num,dp[j]);
            }
        }
    }
    cout<<num<<'\n';
    return 0;
}
/**************************************************************
    Problem: 24258
    User: 2024JK070430
    Language: C++
    Result: 正确
    Time:6 ms
    Memory:3004 kb
****************************************************************/
/*
题目分析
小明每天获得1个资源，已知接下来n天每天商店装备的价格和强度。他只能在装备出现的当天购买，过后无法购买。目标是选择购买的装备，使得总强度最大，且满足以下条件：

购买的装备总价格不超过购买的最后一天的天数（因为到第k天时，小明有k个资源）

每个装备的价格必须小于等于购买当天的天数（否则无法购买）

解题思路
这是一个动态规划问题，类似于01背包问题，但有特殊的约束条件：

背包容量为天数（最大n）

每个物品（装备）只能在特定的一天考虑购买

物品的价值是强度，重量是价格

具体思路：

状态定义：dp[j]表示花费资源j时能获得的最大强度总和

状态转移：

对于第i天（从1到n）：

如果装备价格a <= i（满足购买条件）

从大到小遍历j（从i到a）更新状态：
dp[j] = max(dp[j], dp[j - a] + b)

初始化：dp[0..n] = 0（可以不买任何装备）

结果：所有dp[j]中的最大值
*/
/*
#include <stdio.h>

#define max(a, b) ((a) > (b) ? (a) : (b))

int main() {
    int n;
    scanf("%d", &n);
    
    int dp[n+1]; // dp[j]表示花费j资源时的最大强度
    for (int i = 0; i <= n; i++) {
        dp[i] = 0;
    }
    
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int a, b;
        scanf("%d %d", &a, &b);
        
        // 只有满足价格<=当前天数才能购买
        if (a <= i) {
            // 倒序更新，避免重复选择
            for (int j = i; j >= a; j--) {
                dp[j] = max(dp[j], dp[j - a] + b);
                // 更新当前最大强度
                if (dp[j] > ans) ans = dp[j];
            }
        }
    }
    
    printf("%d\n", ans);
    return 0;
}
代码解释
初始化：

创建dp数组，大小为n+1（资源使用量从0到n）

初始化所有dp[j] = 0，表示初始状态没有购买任何装备

处理每天装备：

读取当天装备的价格a和强度b

检查是否满足购买条件：a <= i（第i天资源足够购买）

如果满足条件，从大到小更新dp[j]：

dp[j] = max(不买当前装备, 买当前装备)

买当前装备：dp[j - a] + b（花费a资源获得b强度）

更新答案：

在更新dp[j]的同时，记录遇到的最大值

输出结果：

打印整个过程中记录的最大强度值

复杂度分析
时间复杂度：O(n²)，对于每个装备，最坏情况下需要O(n)时间更新状态

空间复杂度：O(n)，只需要一个大小为n+1的dp数组

该算法高效地解决了问题，在给定数据范围（n≤5000）内可以快速求解。
*/
